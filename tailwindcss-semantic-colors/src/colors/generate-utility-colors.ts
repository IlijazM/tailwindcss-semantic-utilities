import { TAILWIND_COLORS_STEPS } from '../common.ts';
import { ALL_COLOR_TYPES, COLOR_TYPES, TailwindCssSemanticColorsOptions } from '../options.ts';
import { Colors } from './generate-colors.ts';

/**
 * Generates all utility colors.
 *
 * Utility colors are colors used as a basis for further colors.
 * The idea of the plugin `@ilijazm/tailwindcss-semantic-colors`
 * is to introduce semantic colors that builds a layer of abstraction above the utility based approach
 * which uses colors by their names instead of their uses and provides eleven variants of them.
 *
 * So utility colors as defined here and generated by this function
 * are not intended to be used like the existing utility colors provided by tailwind.
 * Rather, they are necessary in order to generate e.g. surface colors.
 *
 * Utility colors are all colors with the following format: `--color-<colorName>-<utilityColorStep>`.
 * E.g. `--color-primary-500`, `--color-secondary-200`, `color-tertiary-800`, etc..
 *
 * `colorName` includes all colors included in all color types meaning: semantic colors, surface colors, and content
 * colors.
 *
 * `utilityColorStep` range from 50 to 950 like in regular tailwind colors.
 *
 * @example
 * Given the color mappings `primary` and `secondary` the result would look like this:
 *
 * ```json
 * {
 *   "primary-50": "var(--color-indigo-50)",
 *   "primary-100": "var(--color-indigo-100)",
 *   "primary-200": "var(--color-indigo-200)",
 *   ...
 *   "primary-800": "var(--color-indigo-800)",
 *   "primary-900": "var(--color-indigo-900)",
 *   "primary-950": "var(--color-indigo-950)",
 *   "secondary-50": "var(--color-pink-50)",
 *   "secondary-100": "var(--color-pink-100)",
 *   ...
 * }
 * ```
 *
 * @see BASE_COLORS
 * @see UTILITY_COLOR_STEPS
 * @param options a reference to the options object.
 * @returns the generated utility colors.
 */
export class GenerateUtilityColors {
  private readonly UTILITY_COLOR_STEPS = TAILWIND_COLORS_STEPS;

  private result: Colors = {};
  private options: TailwindCssSemanticColorsOptions;

  constructor(options: TailwindCssSemanticColorsOptions) {
    this.options = options;
  }

  generate(): Colors {
    // this.result = {};

    // for (const colorType of ALL_COLOR_TYPES) {
    //   this.generateFromColorType(colorType);
    // }

    // return this.result;

    return Object.assign({}, ...ALL_COLOR_TYPES.map((colorType) => this.generateFromColorType(colorType)));
  }

  private get themeOverrides() {
    return this.options.getThemeOverridesFor(['semanticColors', 'surfaceColors', 'contentColors']);
  }

  private generateFromColorType(colorType: COLOR_TYPES): Colors {
    const colors = this.options.get(colorType);
    return Object.assign(
      {},
      ...Object.entries(colors).map(([color, mapping]) => this.generateFromColor(colorType, color, mapping)),
    );
  }

  private generateFromColor(colorType: COLOR_TYPES, color: string, mapping: string[]): Colors {
    return Object.assign(
      {},
      ...this.UTILITY_COLOR_STEPS.map((step, stepIndex) =>
        this.generateFromColorStep(colorType, color, mapping, step, stepIndex),
      ),
    );
  }

  private generateFromColorStep(
    colorType: COLOR_TYPES,
    color: string,
    mapping: string[],
    step: number,
    stepIndex: number,
  ): Colors {
    if (this.themeOverrides.includes(color)) {
      return this.generateThemeOverride(colorType, color, mapping, step, stepIndex);
    } else {
      return this.generateUnthemedColor(color, mapping, step, stepIndex);
    }
  }

  private generateThemeOverride(
    colorType: COLOR_TYPES,
    color: string,
    mapping: string[],
    step: number,
    stepIndex: number,
  ): Colors {
    return Object.assign(
      {},
      ...this.options.themes.map((theme) => ({
        [`--color-${color}-${step}-theme-${theme}`]:
          this.options.themeOverrides[theme]?.[colorType]?.[color]?.[stepIndex] ?? mapping[stepIndex]!,
      })),
      { [`--color-${color}-${step}`]: `var(--colors-${color}-${step}-theme-${this.options.get('defaultTheme')})` },
    );
  }

  private generateUnthemedColor(color: string, mapping: string[], step: number, stepIndex: number): Colors {
    return { [`--color-${color}-${step}`]: mapping[stepIndex]! };
  }
}
