import { TAILWIND_COLORS_STEPS } from '../common.ts';
import { TailwindCssSemanticColorsOptions } from '../options.ts';
import { Colors } from './generate-colors.ts';

/**
 * Generates all utility colors.
 *
 * Utility colors are colors used as a basis for further colors.
 * The idea of the plugin `@ilijazm/tailwindcss-semantic-colors`
 * is to introduce semantic colors that builds a layer of abstraction above the utility based approach
 * which uses colors by their names instead of their uses and provides eleven variants of them.
 *
 * So utility colors as defined here and generated by this function
 * are not intended to be used like the existing utility colors provided by tailwind.
 * Rather, they are necessary in order to generate e.g. surface colors.
 *
 * Utility colors are all colors with the following format: `--color-<colorName>-<utilityColorStep>`.
 * E.g. `--color-primary-500`, `--color-secondary-200`, `color-tertiary-800`, etc..
 *
 * `colorName` includes all colors included in all color types meaning: semantic colors, surface colors, and content
 * colors.
 *
 * `utilityColorStep` range from 50 to 950 like in regular tailwind colors.
 *
 * @example
 * Given the color mappings `primary` and `secondary` the result would look like this:
 *
 * ```json
 * {
 *   "primary-50": "var(--color-indigo-50)",
 *   "primary-100": "var(--color-indigo-100)",
 *   "primary-200": "var(--color-indigo-200)",
 *   ...
 *   "primary-800": "var(--color-indigo-800)",
 *   "primary-900": "var(--color-indigo-900)",
 *   "primary-950": "var(--color-indigo-950)",
 *   "secondary-50": "var(--color-pink-50)",
 *   "secondary-100": "var(--color-pink-100)",
 *   ...
 * }
 * ```
 *
 * @see BASE_COLORS
 * @see UTILITY_COLOR_STEPS
 * @param options a reference to the options object.
 * @returns the generated utility colors.
 */
export function generateUtilityColors(options: TailwindCssSemanticColorsOptions): Colors {
  const result: Colors = {};

  // Colors steps like the colors steps defined by tailwindcss.
  const UTILITY_COLOR_STEPS = TAILWIND_COLORS_STEPS;

  const themeOverrides = options.getThemeOverridesFor(['semanticColors', 'surfaceColors', 'contentColors']);

  const colors = {
    ...options.get('semanticColors'),
    ...options.get('surfaceColors'),
    ...options.get('contentColors'),
  };

  // Generate cross product between colors and color steps.
  for (const [color, mapping] of Object.entries(colors)) {
    for (const step of UTILITY_COLOR_STEPS) {
      if (themeOverrides.includes(color)) {
        for (const theme of options.themes) {
          result[`${color}-${step}-theme-${theme}`] = mapping[TAILWIND_COLORS_STEPS.indexOf(step)]!;
        }
        // Cannot be undefined because color is a key of semanticColorMapping.

        result[`${color}-${step}`] = `var(--colors-${color}-${step}-theme-${options.get('defaultTheme')})`;
      } else {
        // Cannot be undefined because color is a key of semanticColorMapping.
        result[`${color}-${step}`] = mapping[TAILWIND_COLORS_STEPS.indexOf(step)]!;
      }
    }
  }

  return result;
}
