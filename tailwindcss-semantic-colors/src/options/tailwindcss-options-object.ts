// Polyfill
const structuredClone = (v: any): Record<string, any> => JSON.parse(JSON.stringify(v));

export class TailwindcssOptionsObject<OptionsType extends Record<string, any>> {
  private options: OptionsType;

  constructor(options: unknown, defaultOptions: OptionsType) {
    if (options && typeof options === 'object') {
      this.options = this.merge(defaultOptions, options);
    } else {
      this.options = defaultOptions;
    }
  }

  /**
   * Retrieves the value associated with the given `key` from `this.options`.
   *
   * This method returns a combined result constructed as follows:
   *
   * 1. If `this.options` contains an entry exactly matching `key`, its value is used as the starting object.
   *
   * 2. Then, all entries in `this.options` whose keys begin with `${key}.` (using dot notation) are
   *    interpreted as nested paths extending or overriding parts of the starting object.
   *    These nested keys are parsed and merged into the resulting object.
   *
   * This allows you to specify partial configurations using dot notation keys that augment or
   * override properties within the main object associated with `key`.
   *
   * **Important:** If you want to completely replace the value associated with `key`, do not use dot notation keys.
   * Instead, set the entire value at `key` directly.
   *
   * @example This is an example based on extending an object using the dot notion.
   *
   * ```ts
   * const options = new TailwindcssOptionsObject({
   *   colors: { primary: "blue" },
   *   "colors.success": "green"
   * }, {});
   *
   * options.get("colors"); // returns { primary: "blue", success: "green" }
   * ```
   *
   * @example This is an example showcasing the nested extension using the dot notation.
   * ```ts
   * const options = new TailwindcssOptionsObject({
   *   colors: { primary: { dark: "blue" } },
   *   "colors.primary.light": "cyan"
   * }, {});
   *
   * options.get("colors"); // returns { primary: { dark: "blue", light: "cyan" } }
   * ```
   *
   * @generated by Chat-GPT
   * @param key The key under which the desired value and any nested overrides are stored.
   * @returns An object that merges the value at `key` with all nested dot notation entries beginning with `${key}.`.
   */
  get<K extends keyof OptionsType>(key: K): OptionsType[K] extends object ? OptionsType[K] : Record<string, unknown> {
    const result = {} as OptionsType[K] extends object ? OptionsType[K] : Record<string, unknown>;

    // Direct access
    const directObject = this.options[key];
    if (typeof directObject === 'object' && directObject !== null) {
      Object.assign(result, directObject);
    }

    // Indirect access (dot notation)
    for (const optionKey in this.options) {
      if (optionKey.startsWith(`${String(key)}.`)) {
        const path = optionKey.slice(String(key).length + 1).split('.');
        let current = result as Record<string, unknown>;

        for (let i = 0; i < path.length - 1; i++) {
          const segment = path[i] ?? '';
          if (!(segment in current) || typeof current[segment] !== 'object') {
            current[segment] = {};
          }
          current = current[segment] as Record<string, unknown>;
        }

        const lastSegment = path[path.length - 1] ?? '';
        current[lastSegment] = this.options[optionKey];
      }
    }

    return result;
  }

  /**
   * Merges `options` into `defaultConfig`.
   *
   * This method uses `defaultConfig` as the base and overrides its fields with corresponding entries from `options`.
   * The `options` object has no guarantee to use correct keys and values since it is user input,
   * so it is not assumed to conform to any schema.
   *
   * The structure and types defined in `defaultConfig` serve as a reference for interpreting `options`.
   * For example, if a field in `defaultConfig` is an object,
   * the corresponding field in `options` must also be an object.
   *
   * Due to limitations of the Tailwind CSS plugin API (when using the `@plugin` directive in the CSS file),
   * plugin configuration must use arrays. Deeply nested objects are not allowed.
   * To support this, this function implements a conversion mechanism:
   * if the `defaultConfig` expects an object but `options` provides an array, each array item
   * is interpreted as a key to include from the default. If the item includes a colon (`:`), the value after
   * the colon is used as the new value for the key.
   *
   * If a key is specified in the array, all other keys from the default for that field are excluded.
   *
   * @example Excluding keys from the default config:
   *
   * ```ts
   * const defaultConfig = {
   *    colors: { primary: "indigo", secondary: "pink" }
   * };
   *
   * const options = {
   *    colors: ["primary"]
   * };
   *
   * this.merge(defaultConfig, options); // returns { colors: { primary: "indigo" } }
   * ```
   *
   * @example Overriding a default value:
   *
   * ```ts
   * const defaultConfig = {
   *    colors: { primary: "indigo", secondary: "pink" }
   * };
   *
   * const options = {
   *    colors: ["primary:amber"]
   * };
   *
   * this.merge(defaultConfig, options); // returns { colors: { primary: "amber" } }
   * ```
   *
   * @param defaultConfig The default configuration used as the base and schema for merging.
   * @param options A user-defined object with potential overrides, not guaranteed to follow the expected schema.
   * @returns A merged configuration object that combines `defaultConfig` with the values from `options`.
   */
  private merge(defaultConfig: OptionsType, options: Record<string, any>): OptionsType {
    const result = structuredClone(defaultConfig) as Record<string, any>;

    for (const key in options) {
      const defaultValue = defaultConfig[key];
      const override = options[key];

      if (
        defaultValue &&
        typeof defaultValue === 'object' &&
        !Array.isArray(defaultValue) &&
        (Array.isArray(override) || typeof override === 'string')
      ) {
        const mergedField: Record<string, any> = {};

        for (const item of typeof override === 'string' ? [override] : override) {
          if (typeof item !== 'string') continue;

          const [rawKey, rawValue] = item.split(':').map((part) => part.trim());

          // Ensure rawKey is a non-empty string
          if (rawKey && typeof rawKey === 'string' && rawKey in defaultValue) {
            mergedField[rawKey] = rawValue || defaultValue[rawKey];
          }
        }

        result[key] = mergedField;
      } else {
        result[key] = override;
      }
    }

    return result as OptionsType;
  }
}
