import { attemptToParseColorValueArray } from './color-value-array.ts';

// Polyfill
const structuredClone = <T>(v: T): T => JSON.parse(JSON.stringify(v));

/**
 * A typed object wrapper for the options object provided by TailwindCss.
 */
export class TailwindcssOptionsObject<OptionsType extends Record<string, any>> {
  private readonly options: OptionsType;

  constructor(options: unknown, defaultOptions: OptionsType) {
    if (options && typeof options === 'object') {
      this.options = this.merge(defaultOptions, options);
    } else {
      this.options = defaultOptions;
    }
  }

  get<K extends keyof OptionsType>(key: K): OptionsType[K] extends object ? OptionsType[K] : Record<string, unknown> {
    return this.options[key];
  }

  /**
   * Retrieves the value associated with the given `key` from `this.options`.
   *
   * This method returns a combined result constructed as follows:
   *
   * 1. If `this.options` contains an entry exactly matching `key`, its value is used as the starting object.
   *
   * 2. Then, all entries in `this.options` whose keys begin with `${key}.` (using dot notation) are
   *    interpreted as nested paths extending or overriding parts of the starting object.
   *    These nested keys are parsed and merged into the resulting object.
   *
   * This allows you to specify partial configurations using dot notation keys that augment or
   * override properties within the main object associated with `key`.
   *
   * **Important:** If you want to completely replace the value associated with `key`, do not use dot notation keys.
   * Instead, set the entire value at `key` directly.
   *
   * @example This is an example based on extending an object using the dot notion.
   *
   * ```ts
   * const options = new TailwindcssOptionsObject({
   *   palette: { primary: "blue" },
   *   "palette.success": "green"
   * }, {});
   *
   * options.get("palette"); // returns { primary: "blue", success: "green" }
   * ```
   *
   * @example This is an example showcasing the nested extension using the dot notation.
   * ```ts
   * const options = new TailwindcssOptionsObject({
   *   palette: { primary: { dark: "blue" } },
   *   "palette.primary.light": "cyan"
   * }, {});
   *
   * options.get("palette"); // returns { primary: { dark: "blue", light: "cyan" } }
   * ```
   *
   * @generated by Chat-GPT
   * @param key The key under which the desired value and any nested overrides are stored.
   * @returns An object that merges the value at `key` with all nested dot notation entries beginning with `${key}.`.
   */
  collect<K extends keyof OptionsType>(options: any, key: K): any {
    const result = {};

    // Direct access
    const directObject = options[key];
    if (typeof directObject === 'object' && directObject !== null) {
      Object.assign(result, directObject);
    }

    // Indirect access (dot notation)
    for (const optionKey in options) {
      if (optionKey.startsWith(`${String(key)}.`)) {
        const path = optionKey.slice(String(key).length + 1).split('.');
        let current = result as Record<string, unknown>;

        for (let i = 0; i < path.length - 1; i++) {
          const segment = path[i] ?? '';
          if (!(segment in current) || typeof current[segment] !== 'object') {
            current[segment] = {};
          }
          current = current[segment] as Record<string, unknown>;
        }

        const lastSegment = path[path.length - 1] ?? '';
        current[lastSegment] = options[optionKey];
      }
    }

    return result;
  }

  /**
   * Merges `options` into `defaultConfig`.
   *
   * This method uses `defaultConfig` as the base and overrides its fields with corresponding entries from `options`.
   * The `options` object has no guarantee to use correct keys and values since it is user input,
   * so it is not assumed to conform to any schema.
   *
   * The structure and types defined in `defaultConfig` serve as a reference for interpreting `options`.
   * For example, if a field in `defaultConfig` is an object,
   * the corresponding field in `options` must also be an object.
   *
   * Due to limitations of the Tailwind CSS plugin API (when using the `@plugin` directive in the CSS file),
   * plugin configuration must use arrays. Deeply nested objects are not allowed.
   * To support this, this function implements a conversion mechanism:
   * if the `defaultConfig` expects an object but `options` provides an array, each array item
   * is interpreted as a key to include from the default. If the item includes a colon (`:`), the value after
   * the colon is used as the new value for the key.
   *
   * If a key is specified in the array, all other keys from the default for that field are excluded.
   *
   * @example Excluding keys from the default config:
   *
   * ```ts
   * const defaultConfig = {
   *    palette: { primary: "indigo", secondary: "pink" }
   * };
   *
   * const options = {
   *    palette: ["primary"]
   * };
   *
   * this.merge(defaultConfig, options); // returns { palette: { primary: "indigo" } }
   * ```
   *
   * @example Overriding a default value:
   *
   * ```ts
   * const defaultConfig = {
   *    palette: { primary: "indigo", secondary: "pink" }
   * };
   *
   * const options = {
   *    palette: ["primary:amber"]
   * };
   *
   * this.merge(defaultConfig, options); // returns { palette: { primary: "amber" } }
   * ```
   *
   * @param defaultConfig The default configuration used as the base and schema for merging.
   * @param options A user-defined object with potential overrides, not guaranteed to follow the expected schema.
   * @returns A merged configuration object that combines `defaultConfig` with the values from `options`.
   */
  private merge<K extends keyof OptionsType>(defaultConfig: OptionsType, options: Record<string, any>): OptionsType {
    const mergedOptions = structuredClone(defaultConfig);

    options = this.cleanUpOptionsObject(options);

    // We need to start with the smallest keys so that the keys with the dot notation get added afterwards.
    const optionKeys = Object.keys(options).sort((a, b) => a.length - b.length) as K[];

    for (const key of optionKeys) {
      if (key in defaultConfig) {
        mergedOptions[key] = this.evaluateValue(defaultConfig[key], options[key as string]);
      } else {
        const path = key.toString().split('.');

        let currentPartialOfMergedOptions: any = mergedOptions;

        for (let i = 0; i < path.length - 1; i++) {
          currentPartialOfMergedOptions = currentPartialOfMergedOptions[path[i]!];
        }
        currentPartialOfMergedOptions[path[path.length - 1]!] = this.evaluateValue(
          currentPartialOfMergedOptions[path[path.length - 1]!],
          options[key as string],
        );
      }
    }

    return mergedOptions;
  }

  private cleanUpOptionsObject(options: Record<string, any>): Record<string, any> {
    // This is because tailwind css passes option keys in quotations which is not desired.

    options = Object.fromEntries(
      Object.entries(options).map(([key, value]) => [key.replace(/^"/, '').replace(/"$/, ''), value]),
    );

    return options;
  }

  private evaluateValue(defaultValue: any, overrideValue: any): any {
    if (!defaultValue) {
      return overrideValue;
    }

    if (!(typeof defaultValue === 'object')) {
      return overrideValue;
    }

    if (typeof overrideValue === 'object' && !Array.isArray(overrideValue)) {
      return overrideValue;
    }

    if (Array.isArray(defaultValue)) {
      if (Array.isArray(overrideValue)) {
        return overrideValue;
      }

      if (typeof overrideValue === 'string') {
        return [overrideValue];
      }

      throw new Error(`Unexpected type of overrideValue '${typeof overrideValue}'.`);
    }

    if (!Array.isArray(defaultValue)) {
      if (typeof overrideValue === 'string') {
        overrideValue = [overrideValue];
      }

      const mergedField: Record<string, any> = {};

      for (const item of overrideValue) {
        if (typeof item !== 'string') {
          continue;
        }

        const [rawKey, rawValue] = item.split(':').map((part) => part.trim());

        if (rawKey && typeof rawKey === 'string') {
          let parsedValue = defaultValue[rawKey];

          if (rawValue) {
            const colorValueArray = attemptToParseColorValueArray(rawValue);
            if (colorValueArray !== false) {
              parsedValue = colorValueArray;
            } else {
              parsedValue = rawValue;
            }
          }

          mergedField[rawKey] = parsedValue;
        }
      }

      return mergedField;
    }
  }
}
