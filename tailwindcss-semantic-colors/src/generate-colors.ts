import { TAILWIND_COLORS_STEPS } from '@src/common.ts';

export type ColorValue = string;
export type Colors = { [colorName: ColorValue]: ColorValue };

/**
 * Holds all the color types as a parameter interface:
 *
 * * semantic colors
 * * surface colors
 * * content colors
 */
interface GenerateColorsParams {
  semanticColorMapping: Record<string, string[]>;
  surfaceColorMapping: Record<string, string[]>;
  contentColorMapping: Record<string, string[]>;
}

/**
 * Generates all colors.
 *
 * @param generateColorParams the color mappings of semantic, surface, and content colors.
 * @returns the generated colors.
 */
export function generateColors(generateColorParams: GenerateColorsParams): Colors {
  return {
    ...generateUtilityColors(generateColorParams),
    ...generateSemanticColors(generateColorParams),
    ...generateSurfaceColors(generateColorParams),
    ...generateContentColors(generateColorParams),
  };
}

/**
 * Generates all utility colors.
 *
 * Utility colors are colors used as a basis for further colors.
 * The idea of the plugin `@ilijazm/tailwindcss-semantic-colors`
 * is to introduce semantic colors that builds a layer of abstraction above the utility based approach
 * which uses colors by their names instead of their uses and provides eleven variants of them.
 *
 * So utility colors as defined here and generated by this function
 * are not intended to be used like the existing utility colors provided by tailwind.
 * Rather, they are necessary in order to generate e.g. surface colors.
 *
 * Utility colors are all colors with the following format: `--color-<colorName>-<utilityColorStep>`.
 * E.g. `--color-primary-500`, `--color-secondary-200`, `color-tertiary-800`, etc..
 *
 * `colorName` includes all colors included in all color types meaning: semantic colors, surface colors, and content
 * colors.
 *
 * `utilityColorStep` range from 50 to 950 like in regular tailwind colors.
 *
 * @example
 * Given the color mappings `primary` and `secondary` the result would look like this:
 *
 * ```json
 * {
 *   "primary-50": "var(--color-indigo-50)",
 *   "primary-100": "var(--color-indigo-100)",
 *   "primary-200": "var(--color-indigo-200)",
 *   ...
 *   "primary-800": "var(--color-indigo-800)",
 *   "primary-900": "var(--color-indigo-900)",
 *   "primary-950": "var(--color-indigo-950)",
 *   "secondary-50": "var(--color-pink-50)",
 *   "secondary-100": "var(--color-pink-100)",
 *   ...
 * }
 * ```
 *
 * @see BASE_COLORS
 * @see UTILITY_COLOR_STEPS
 * @param generateColorParams the color mappings of semantic, surface, and content colors.
 * @returns the generated utility colors.
 */
function generateUtilityColors({
  semanticColorMapping,
  surfaceColorMapping,
  contentColorMapping,
}: GenerateColorsParams): Colors {
  // Colors steps like the colors steps defined by tailwindcss.
  const UTILITY_COLOR_STEPS = TAILWIND_COLORS_STEPS;

  const colors = {
    ...semanticColorMapping,
    ...surfaceColorMapping,
    ...contentColorMapping,
  };

  const result: Colors = {};

  // Generate cross product between colors and color steps.
  for (const [color, mapping] of Object.entries(colors)) {
    for (const step of UTILITY_COLOR_STEPS) {
      // Cannot be undefined because color is a key of semanticColorMapping.
      result[`${color}-${step}`] = mapping[TAILWIND_COLORS_STEPS.indexOf(step)]!;
    }
  }

  return result;
}

/**
 * Generates all semantic colors.
 *
 * Semantic colors are intended to be used for buttons, highlights text, strong backgrounds, etc.
 *
 * Semantic colors are all colors with the following format: `--color-<semanticColorName>-<semanticColorSteps>`.
 * E.g. `--color-primary`, `--color-secondary-light`, `--color-tertiary-dark`, etc.
 *
 * `semanticColorName` includes all semantic colors included in `semanticColorMapping`.
 * These are e.g. `primary`, `secondary`, `info`, etc.
 *
 * `semanticColorStep` are defined in the constant variable `SEMANTIC_COLOR_STEPS`.
 *
 * @example
 * Given the semantic color mapping `primary` and `secondary` the result would look like this:
 *
 * ```json
 * {
 *   "primary": "var(--color-primary-600)",
 *   "primary-light": "var(--color-primary-500)",
 *   "primary-dark": "var(--color-primary-700)",
 *   "secondary": "var(--color-secondary-600)",
 *   "secondary-light": "var(--color-secondary-500)",
 *   "secondary-dark": "var(--color-secondary-700)"
 * }
 * ```
 *
 * @see SEMANTIC_COLOR_STEPS
 * @param generateColorParams the color mappings of semantic, surface, and content colors.
 * @returns the generated semantic colors.
 */
function generateSemanticColors({ semanticColorMapping }: GenerateColorsParams): Colors {
  const SEMANTIC_COLOR_STEPS = { '': 600, '-light': 500, '-dark': 700 };

  const result: Colors = {};

  const colors = Object.keys(semanticColorMapping);

  // Generate cross product between colors and color steps.
  for (const color of colors) {
    for (const [sourceStep, targetStep] of Object.entries(SEMANTIC_COLOR_STEPS)) {
      result[`${color}${sourceStep}`] = `var(--color-${color}-${targetStep})`;
    }
  }

  return result;
}

/**
 * Generates all surface colors.
 *
 * Surface colors are intended to be used for buttons, panels, light backgrounds, etc.
 *
 * Surface colors are all colors with the following format `--color-surface-<colorName>-<surfaceStep>.
 *
 * `colorName` includes all semantic colors included in `semanticColorMapping`.
 * These are e.g. `primary`, `secondary`, `info`, etc.
 * Additionally `colorName` also includes all surface colors included in `surfaceColorMapping`.
 * These are e.g. `surface`, `container`, etc.
 *
 * `surfaceStep` differ from semantic colors and surface colors.
 * `surfaceStep` for semantic colors are defined in the variable `SURFACE_STEPS`.
 * `surfaceStep` for surface colors are defined in the variable `SURFACE_STEPS_EXTRA`.
 *
 * @example
 * Given the semantic and surface color mappings `surface`, `primary`, and `secondary` the result would look like this:
 *
 * ```json
 * {
 *   "surface": "var(--color-surface-100)",
 *   "surface-light": "var(--color-surface-50)",
 *   "surface-lightest": "var(--color-white)",
 *   "surface-dark": "var(--color-surface-100)",
 *   "surface-darkest": "var(--color-surface-200)",
 *   "surface-primary": "var(--color-primary-100)",
 *   "surface-primary-light": "var(--color-primary-50)",
 *   "surface-primary-dark": "var(--color-primary-200)",
 *   "surface-secondary": "var(--color-secondary-100)",
 *   "surface-secondary-light": "var(--color-secondary-50)",
 *   "surface-secondary-dark": "var(--color-secondary-200)"
 * }
 * ```
 *
 * @see SURFACE_STEPS
 * @see SURFACE_STEPS_EXTRA
 * @param generateColorParams the color mappings of semantic, surface, and content colors.
 * @returns the generated surface colors.
 */
function generateSurfaceColors({ semanticColorMapping, surfaceColorMapping }: GenerateColorsParams): Colors {
  const SURFACE_STEPS = { '': 100, '-light': 50, '-dark': 200 };

  // extend the surface steps for the surface colors.
  const SURFACE_STEPS_EXTRA = { ...SURFACE_STEPS, '-lightest': 'white', '-darkest': 300 };

  const result: Colors = {};

  const semanticColors = Object.keys(semanticColorMapping);

  // Generate cross product between semantic colors and color steps.
  for (const color of semanticColors) {
    for (const [sourceStep, targetStep] of Object.entries(SURFACE_STEPS)) {
      result[`surface-${color}${sourceStep}`] = `var(--color-${color}-${targetStep})`;
    }
  }

  const surfaceColors = Object.keys(surfaceColorMapping);

  // Generate cross product between surface colors and color steps.
  for (const color of surfaceColors) {
    for (const [sourceStep, targetStep] of Object.entries(SURFACE_STEPS_EXTRA)) {
      const value = typeof targetStep === 'string' ? targetStep : `var(--color-${color}-${targetStep})`;
      result[`${color}${sourceStep}`] = value;
    }
  }

  return result;
}

/**
 * Generates all content colors.
 *
 * Content colors are intended to be used for text.
 * Text comes in three different emphasis-levels: muted, default, and emphasis.
 *
 * Content colors are all colors with the following format `--<contentColorName>-<contentStep>.
 *
 * `contentColorName` includes all content colors included in `contentColorMapping`.
 * These are e.g. `content`.
 *
 * `contentStep` are defined in the constant variable `CONTENT_STEPS`.
 *
 * @example
 * Given the content color mapping `content` the result would look like this:
 *
 * ```json
 * {
 *   "content": "var(--color-content-900)",
 *   "content-muted": "var(--color-content-800)",
 *   "content-emphasis": "var(--color-black)",
 * }
 * ```
 *
 * @see CONTENT_STEPS
 * @param generateColorParams the color mappings of semantic, surface, and content colors.
 * @returns the generated content colors.
 */
function generateContentColors({ contentColorMapping }: GenerateColorsParams): Colors {
  const CONTENT_STEPS = { '': 900, '-muted': 800, '-emphasis': 'black' };

  const result: Colors = {};

  const colors = Object.keys(contentColorMapping);

  // Generate cross product between semantic colors and color steps.
  for (const color of colors) {
    for (const [sourceStep, targetStep] of Object.entries(CONTENT_STEPS)) {
      const value =
        typeof targetStep === 'string' ? `var(--color-${targetStep})` : `var(--color-${color}-${targetStep})`;
      result[`${color}${sourceStep}`] = value;
    }
  }

  return result;
}
