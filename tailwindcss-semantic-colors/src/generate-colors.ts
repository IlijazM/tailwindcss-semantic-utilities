import { TAILWIND_COLORS_STEPS } from '@src/common.ts';

export type ColorValue = string;
export type Colors = { [colorName: ColorValue]: ColorValue };

/**
 * Generates all colors.
 *
 * @param semanticColorMapping the existing colors and their corresponding mapping.
 * @returns the generated colors.
 */
export function generateColors(
  semanticColorMapping: Record<string, string[]>,
  surfaceColorMapping: Record<string, string[]>,
  contentColorMapping: Record<string, string[]>,
): Colors {
  return {
    ...generateUtilityColors(semanticColorMapping, surfaceColorMapping, contentColorMapping),
    ...generateSemanticColors(semanticColorMapping, surfaceColorMapping, contentColorMapping),
    ...generateSurfaceColors(semanticColorMapping, surfaceColorMapping, contentColorMapping),
  };
}

/**
 * Generates all utility colors.
 *
 * Utility colors are colors used as a basis for further colors.
 * The idea of the plugin `@ilijazm/tailwindcss-semantic-colors`
 * is to introduce semantic colors that builds a layer of abstraction above the utility based approach
 * which uses colors by their names instead of their uses and provides eleven variants of them.
 *
 * So utility colors as defined here and generated by this function
 * are not inteded to be used like the existing utility colors provided by tailwind.
 * Rather, they are necessary in order to generate e.g. surface colors.
 *
 * Utility colors are all colors with the following format: `--color-<colorName>-<utilityColorSteps>`.
 * E.g. `--color-primary-500`, `--color-secondary-200`, `color-tertiary-800`, etc..
 *
 * `colorName` includes all colors included in the `colorMapping`. These are e.g. `primary`, `secondary`, `info`, etc.
 * Additionally, `colorName` includes `BASE_COLORS`.
 *
 * `utilityColorSteps` range from 50 to 950 like in regular tailwind colors.
 *
 * @example
 * Given the color mapping `primary` and `secondary` the result would look like this:
 *
 * ```json
 * {
 *   "primary-50": "var(--color-indigo-50)",
 *   "primary-100": "var(--color-indigo-100)",
 *   "primary-200": "var(--color-indigo-200)",
 *   ...
 *   "primary-800": "var(--color-indigo-800)",
 *   "primary-900": "var(--color-indigo-900)",
 *   "primary-950": "var(--color-indigo-950)",
 *   "secondary-50": "var(--color-pink-50)",
 *   "secondary-100": "var(--color-pink-100)",
 *   ...
 * }
 * ```
 *
 * @see BASE_COLORS
 * @see UTILITY_COLOR_STEPS
 * @param colorMapping the existing colors and their corresponding mapping.
 * @returns the generated colors.
 */
function generateUtilityColors(
  semanticColorMapping: Record<string, string[]>,
  surfaceColorMapping: Record<string, string[]>,
  contentColorMapping: Record<string, string[]>,
): Colors {
  // Colors steps like the colors steps defined by tailwindcss.
  const UTILITY_COLOR_STEPS = TAILWIND_COLORS_STEPS;

  const result: Colors = {};

  for (const color of Object.keys(semanticColorMapping)) {
    let i = 0;
    for (const step of UTILITY_COLOR_STEPS) {
      // Cannot be undefined because color is a key of semanticColorMapping.
      result[`${color}-${step}`] = semanticColorMapping[color]![i++]!;
    }
  }

  for (const color of Object.keys(surfaceColorMapping)) {
    let i = 0;
    for (const step of UTILITY_COLOR_STEPS) {
      result[`${color}-${step}`] = surfaceColorMapping[color]![i++]!;
    }
  }

  for (const color of Object.keys(contentColorMapping)) {
    let i = 0;
    for (const step of UTILITY_COLOR_STEPS) {
      result[`${color}-${step}`] = contentColorMapping[color]![i++]!;
    }
  }

  return result;
}

/**
 * Generates all semantic colors.
 *
 * Semantic colors are intended to be used for buttons, highlightes text, strong backgrounds, etc.
 *
 * Semantic colors are all colors with the following format: `--color-<colorName>-<semanticColorSteps>`.
 * E.g. `--color-primary`, `--color-secondary-light`, `--color-tertiary-dark`, etc.
 *
 * `colorName` includes all colors included in the `colorMapping`. These are e.g. `primary`, `secondary`, `info`, etc.
 *
 * `semanticColorSteps` are defined in the constant variable `SEMANTIC_COLOR_STEPS`.
 *
 * @example
 * Given the color mapping `primary` and `secondary` the result would look like this:
 *
 * ```json
 * {
 *   "primary": "var(--color-primary-600)",
 *   "primary-light": "var(--color-primary-500)",
 *   "primary-dark": "var(--color-primary-700)",
 *   "secondary": "var(--color-secondary-600)",
 *   "secondary-light": "var(--color-secondary-500)",
 *   "secondary-dark": "var(--color-secondary-700)"
 * }
 * ```
 *
 * @see SEMANTIC_COLOR_STEPS
 * @param colorMapping the existing colors and their corresponding mapping.
 * @returns the generated colors.
 */
function generateSemanticColors(
  semanticColorMapping: Record<string, string[]>,
  surfaceColorMapping: Record<string, string[]>,
  contentColorMapping: Record<string, string[]>,
): Colors {
  const SEMANTIC_COLOR_STEPS = { '': 600, '-light': 500, '-dark': 700 };

  const result: Colors = {};

  const colors = Object.keys(semanticColorMapping);

  // Generate cross product between colors and color steps.
  for (const color of colors) {
    for (const [sourceStep, targetStep] of Object.entries(SEMANTIC_COLOR_STEPS)) {
      result[`${color}${sourceStep}`] = `var(--color-${color}-${targetStep})`;
    }
  }

  return result;
}

/**
 * Generates all surface colors.
 *
 * Surface colors are intended to be used for buttons, panels, light backgrounds, etc.
 *
 * Surface colors are all colors with the following format `--color-surface-<colorName>-<surfaceStep>.
 *
 * `colorName` includes all colors included in the `colorMapping`. These are e.g. `primary`, `secondary`, `info`, etc.
 *
 * `surfaceSteps` are defined in the constant variable `SURFACE_STEPS`.
 *
 * Additionally, this function includes the surface colors for the color `surface`.
 * The steps for the color `surface` are extended.
 *
 * @example
 * Given the color mapping `primary` and `secondary` the result would look like this:
 *
 * ```json
 * {
 *   "surface": "var(--color-surface-100)",
 *   "surface-light": "var(--color-surface-50)",
 *   "surface-lightest": "var(--color-white)",
 *   "surface-dark": "var(--color-surface-100)",
 *   "surface-darkest": "var(--color-surface-200)",
 *   "surface-primary": "var(--color-primary-100)",
 *   "surface-primary-light": "var(--color-primary-50)",
 *   "surface-primary-dark": "var(--color-primary-200)",
 *   "surface-secondary": "var(--color-secondary-100)",
 *   "surface-secondary-light": "var(--color-secondary-50)",
 *   "surface-secondary-dark": "var(--color-secondary-200)"
 * }
 * ```
 *
 * @see SURFACE_STEPS
 * @see SURFACE_STEPS_EXTRA
 * @param colorMapping the existing colors and their corresponding mapping.
 * @returns the generated colors.
 */
function generateSurfaceColors(
  semanticColorMapping: Record<string, string[]>,
  surfaceColorMapping: Record<string, string[]>,
  contentColorMapping: Record<string, string[]>,
): Colors {
  const SURFACE_STEPS = { '': 100, '-light': 50, '-dark': 200 };

  // extend the surface steps for the surface colors.
  const SURFACE_STEPS_EXTRA = { ...SURFACE_STEPS, '-lightest': 'white', '-darkest': 300 };

  const result: Colors = {};

  // Colors include the inputted colors and the surface color.
  const semanticColors = Object.keys(semanticColorMapping);

  // Generate cross product between colors and color steps.
  for (const color of semanticColors) {
    for (const [sourceStep, targetStep] of Object.entries(SURFACE_STEPS)) {
      result[`surface-${color}${sourceStep}`] = `var(--color-${color}-${targetStep})`;
    }
  }

  const surfaceColors = Object.keys(surfaceColorMapping);

  // Generate cross product between colors and color steps.
  for (const color of surfaceColors) {
    for (const [sourceStep, targetStep] of Object.entries(SURFACE_STEPS_EXTRA)) {
      const value = typeof targetStep === 'string' ? targetStep : `var(--color-${color}-${targetStep})`;
      result[`${color}${sourceStep}`] = value;
    }
  }

  return result;
}
